name: Deploy to Environment

on:
  workflow_run:
    workflows: ["CI/CD 流程"]
    types: [completed]
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        default: 'rolling'
        type: choice
        options:
          - rolling
          - blue-green
          - canary
      force_deploy:
        description: 'Force deployment even if tests failed'
        required: false
        default: false
        type: boolean
      rollback_version:
        description: 'Version to rollback to (leave empty for normal deployment)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}
  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      deployment_strategy: ${{ steps.strategy.outputs.deployment_strategy }}
    steps:
      - name: Determine target environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Check if deployment should proceed
        id: check
        run: |
          SHOULD_DEPLOY="false"
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            SHOULD_DEPLOY="true"
          elif [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            SHOULD_DEPLOY="true"
            echo "⚠️ Force deployment requested despite test failures"
          fi
          
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT

      - name: Determine deployment strategy
        id: strategy
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "deployment_strategy=${{ github.event.inputs.deployment_strategy }}" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.env.outputs.environment }}" == "production" ]]; then
            echo "deployment_strategy=blue-green" >> $GITHUB_OUTPUT
          else
            echo "deployment_strategy=rolling" >> $GITHUB_OUTPUT
          fi

  pre-deployment-checks:
    needs: determine-environment
    if: needs.determine-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Load environment configuration
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          
          if [[ -f ".github/environments/$ENV.yml" ]]; then
            echo "Loading configuration for $ENV environment"
            cat ".github/environments/$ENV.yml"
          else
            echo "❌ Environment configuration not found for $ENV"
            exit 1
          fi

      - name: Check required environment variables
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          
          # Extract required env vars from config file
          if [[ -f ".github/environments/$ENV.yml" ]]; then
            REQUIRED_VARS=$(yq eval '.required_env_vars[]' ".github/environments/$ENV.yml")
            
            echo "Checking required environment variables for $ENV:"
            MISSING_VARS=""
            
            while IFS= read -r var; do
              if [[ -z "${!var:-}" ]]; then
                echo "❌ Missing: $var"
                MISSING_VARS="$MISSING_VARS $var"
              else
                echo "✅ Found: $var"
              fi
            done <<< "$REQUIRED_VARS"
            
            if [[ -n "$MISSING_VARS" ]]; then
              echo "❌ Missing required environment variables:$MISSING_VARS"
              exit 1
            fi
          fi
        env:
          # Add your environment variables here
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}

      - name: Verify Docker images exist
        run: |
          SERVICES=("community-server" "enterprise-server" "auth-service" "notification-service" "community-admin" "community-mobile" "enterprise-admin")
          TAG="${{ github.sha }}"
          
          echo "Verifying Docker images for tag: $TAG"
          
          for service in "${SERVICES[@]}"; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$service:$TAG"
            echo "Checking image: $IMAGE"
            
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "✅ Image exists: $service"
            else
              echo "❌ Image not found: $service"
              exit 1
            fi
          done

  deploy-staging:
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.environment == 'staging' && needs.determine-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config current-context

      - name: Deploy to staging
        run: |
          export KUBECONFIG=kubeconfig
          TAG="${{ github.sha }}"
          STRATEGY="${{ needs.determine-environment.outputs.deployment_strategy }}"
          
          echo "Deploying to staging with strategy: $STRATEGY"
          
          # Update image tags in kustomization
          cd k8s/overlays/staging
          
          SERVICES=("community-server" "enterprise-server" "auth-service" "notification-service" "community-admin" "community-mobile" "enterprise-admin")
          
          for service in "${SERVICES[@]}"; do
            IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$service"
            yq eval ".images[] |= select(.name == \"$service\").newTag = \"$TAG\"" -i kustomization.yaml
          done
          
          # Apply the deployment
          kubectl apply -k .
          
          # Wait for rollout to complete
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "$service" -n staging > /dev/null 2>&1; then
              echo "Waiting for $service rollout to complete..."
              kubectl rollout status deployment/"$service" -n staging --timeout=600s
            fi
          done

      - name: Run health checks
        run: |
          ENV="staging"
          
          # Load health check endpoints from config
          if [[ -f ".github/environments/$ENV.yml" ]]; then
            echo "Running health checks for $ENV environment"
            
            # Extract health check URLs (simplified - in real scenario you'd parse YAML properly)
            HEALTH_URLS=(
              "https://staging-api-community.phoenixcoder.dev/health"
              "https://staging-api-enterprise.phoenixcoder.dev/health"
              "https://staging-auth.phoenixcoder.dev/health"
              "https://staging-notifications.phoenixcoder.dev/health"
            )
            
            for url in "${HEALTH_URLS[@]}"; do
              echo "Checking health: $url"
              
              for i in {1..30}; do
                if curl -f -s "$url" > /dev/null; then
                  echo "✅ Health check passed: $url"
                  break
                elif [[ $i -eq 30 ]]; then
                  echo "❌ Health check failed after 30 attempts: $url"
                  exit 1
                else
                  echo "⏳ Attempt $i/30 failed, retrying in 10s..."
                  sleep 10
                fi
              done
            done
          fi

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging environment"
          
          # Install test dependencies
          npm install -g newman
          
          # Run API smoke tests if Postman collection exists
          if [[ -f "tests/smoke/api-smoke-tests.postman_collection.json" ]]; then
            newman run tests/smoke/api-smoke-tests.postman_collection.json \
              --env-var "base_url=https://staging-api-community.phoenixcoder.dev" \
              --reporters cli,json \
              --reporter-json-export smoke-test-results.json
          fi
          
          # Run frontend smoke tests
          if [[ -f "tests/smoke/frontend-smoke.js" ]]; then
            node tests/smoke/frontend-smoke.js
          fi

  deploy-production:
    needs: [determine-environment, pre-deployment-checks]
    if: needs.determine-environment.outputs.environment == 'production' && needs.determine-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          kubectl config current-context

      - name: Create deployment backup
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "Creating backup of current production deployment"
          mkdir -p backups
          
          # Backup current deployment manifests
          kubectl get deployments -n production -o yaml > backups/deployments-backup.yaml
          kubectl get services -n production -o yaml > backups/services-backup.yaml
          kubectl get configmaps -n production -o yaml > backups/configmaps-backup.yaml
          
          # Store current image tags for rollback
          kubectl get deployments -n production -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.template.spec.containers[0].image}{"\n"}{end}' > backups/current-images.txt
          
          echo "Backup created successfully"

      - name: Deploy to production (Blue-Green)
        if: needs.determine-environment.outputs.deployment_strategy == 'blue-green'
        run: |
          export KUBECONFIG=kubeconfig
          TAG="${{ github.sha }}"
          
          echo "Starting Blue-Green deployment to production"
          
          # Create green environment
          cd k8s/overlays/production
          
          # Update image tags
          SERVICES=("community-server" "enterprise-server" "auth-service" "notification-service" "community-admin" "community-mobile" "enterprise-admin")
          
          for service in "${SERVICES[@]}"; do
            yq eval ".images[] |= select(.name == \"$service\").newTag = \"$TAG\"" -i kustomization.yaml
          done
          
          # Deploy green environment
          kubectl apply -k . --dry-run=client -o yaml | sed 's/name: /name: green-/g' | kubectl apply -f -
          
          # Wait for green deployment to be ready
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "green-$service" -n production > /dev/null 2>&1; then
              echo "Waiting for green-$service to be ready..."
              kubectl rollout status deployment/"green-$service" -n production --timeout=600s
            fi
          done
          
          # Run health checks on green environment
          echo "Running health checks on green environment"
          # Add health check logic here
          
          # Switch traffic to green (update services)
          echo "Switching traffic to green environment"
          for service in "${SERVICES[@]}"; do
            if kubectl get service "$service" -n production > /dev/null 2>&1; then
              kubectl patch service "$service" -n production -p '{"spec":{"selector":{"version":"green"}}}'
            fi
          done
          
          # Wait and verify
          sleep 30
          
          # Clean up old blue environment
          echo "Cleaning up old blue environment"
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "$service" -n production > /dev/null 2>&1; then
              kubectl delete deployment "$service" -n production
            fi
          done
          
          # Rename green to current
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "green-$service" -n production > /dev/null 2>&1; then
              kubectl patch deployment "green-$service" -n production -p '{"metadata":{"name":"'$service'"}}'
            fi
          done

      - name: Deploy to production (Rolling)
        if: needs.determine-environment.outputs.deployment_strategy == 'rolling'
        run: |
          export KUBECONFIG=kubeconfig
          TAG="${{ github.sha }}"
          
          echo "Starting Rolling deployment to production"
          
          cd k8s/overlays/production
          
          # Update image tags
          SERVICES=("community-server" "enterprise-server" "auth-service" "notification-service" "community-admin" "community-mobile" "enterprise-admin")
          
          for service in "${SERVICES[@]}"; do
            yq eval ".images[] |= select(.name == \"$service\").newTag = \"$TAG\"" -i kustomization.yaml
          done
          
          # Apply the deployment
          kubectl apply -k .
          
          # Wait for rollout to complete
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "$service" -n production > /dev/null 2>&1; then
              echo "Waiting for $service rollout to complete..."
              kubectl rollout status deployment/"$service" -n production --timeout=600s
            fi
          done

      - name: Run production health checks
        run: |
          echo "Running comprehensive health checks on production"
          
          HEALTH_URLS=(
            "https://api.phoenixcoder.com/health"
            "https://enterprise-api.phoenixcoder.com/health"
            "https://auth.phoenixcoder.com/health"
            "https://notifications.phoenixcoder.com/health"
          )
          
          for url in "${HEALTH_URLS[@]}"; do
            echo "Checking health: $url"
            
            for i in {1..60}; do
              if curl -f -s "$url" > /dev/null; then
                echo "✅ Health check passed: $url"
                break
              elif [[ $i -eq 60 ]]; then
                echo "❌ Health check failed after 60 attempts: $url"
                echo "🔄 Initiating automatic rollback"
                
                # Trigger rollback
                export KUBECONFIG=kubeconfig
                kubectl rollout undo deployment/$(basename $url | cut -d'.' -f1) -n production
                exit 1
              else
                echo "⏳ Attempt $i/60 failed, retrying in 10s..."
                sleep 10
              fi
            done
          done

      - name: Run production smoke tests
        run: |
          echo "Running production smoke tests"
          
          # Install test dependencies
          npm install -g newman
          
          # Run critical path tests
          if [[ -f "tests/smoke/production-critical-path.postman_collection.json" ]]; then
            newman run tests/smoke/production-critical-path.postman_collection.json \
              --env-var "base_url=https://api.phoenixcoder.com" \
              --reporters cli,json \
              --reporter-json-export production-smoke-results.json
          fi

  rollback:
    if: github.event.inputs.rollback_version != ''
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      - name: Configure kubectl
        run: |
          ENV="${{ github.event.inputs.environment }}"
          if [[ "$ENV" == "production" ]]; then
            echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > kubeconfig
          else
            echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > kubeconfig
          fi
          export KUBECONFIG=kubeconfig

      - name: Perform rollback
        run: |
          export KUBECONFIG=kubeconfig
          ENV="${{ github.event.inputs.environment }}"
          ROLLBACK_VERSION="${{ github.event.inputs.rollback_version }}"
          
          echo "Rolling back $ENV environment to version: $ROLLBACK_VERSION"
          
          SERVICES=("community-server" "enterprise-server" "auth-service" "notification-service" "community-admin" "community-mobile" "enterprise-admin")
          
          for service in "${SERVICES[@]}"; do
            if kubectl get deployment "$service" -n "$ENV" > /dev/null 2>&1; then
              echo "Rolling back $service to version $ROLLBACK_VERSION"
              kubectl set image deployment/"$service" "$service"="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}/$service:$ROLLBACK_VERSION" -n "$ENV"
              kubectl rollout status deployment/"$service" -n "$ENV" --timeout=300s
            fi
          done
          
          echo "Rollback completed successfully"

  post-deployment:
    needs: [determine-environment, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    runs-on: ubuntu-latest
    
    steps:
      - name: Update deployment status
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          STATUS="success"
          
          if [[ "${{ needs.deploy-staging.result }}" == "failure" ]] || [[ "${{ needs.deploy-production.result }}" == "failure" ]]; then
            STATUS="failure"
          fi
          
          echo "Deployment to $ENV completed with status: $STATUS"
          echo "Commit: ${{ github.sha }}"
          echo "Deployment strategy: ${{ needs.determine-environment.outputs.deployment_strategy }}"

      - name: Notify deployment status
        run: |
          # Add your notification logic here (Slack, Discord, Email, etc.)
          echo "Sending deployment notifications..."
          
          # Example Slack notification
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Deployment to ${{ needs.determine-environment.outputs.environment }} completed"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Create deployment record
        run: |
          mkdir -p deployment-records
          
          cat > deployment-records/deployment-$(date +%Y%m%d-%H%M%S).json << EOF
          {
            "environment": "${{ needs.determine-environment.outputs.environment }}",
            "commit": "${{ github.sha }}",
            "strategy": "${{ needs.determine-environment.outputs.deployment_strategy }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow_run": "${{ github.run_id }}",
            "status": "success",
            "services": [
              "community-server",
              "enterprise-server",
              "auth-service",
              "notification-service",
              "community-admin",
              "community-mobile",
              "enterprise-admin"
            ]
          }
          EOF

      - name: Upload deployment record
        uses: actions/upload-artifact@v4
        with:
          name: deployment-record-${{ needs.determine-environment.outputs.environment }}
          path: deployment-records/
          retention-days: 90